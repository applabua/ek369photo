<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Авто-вырез: объект в центре</title>
<style>
  body{font-family:Inter, Arial, sans-serif; background:#0b1220; color:#e6eef6; margin:0; padding:20px; display:flex; gap:20px; min-height:100vh; box-sizing:border-box;}
  .card{background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.6);}
  .left{flex:1; display:flex; flex-direction:column; gap:12px;}
  .right{width:320px;}
  h1{margin:0 0 4px 0; font-size:18px;}
  .controls{display:flex; gap:8px; align-items:center;}
  input[type=file]{display:none;}
  label.btn{background:linear-gradient(180deg,#06b6d4,#0ea5b7); color:#012; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700;}
  button{padding:8px 10px; border-radius:8px; border:0; cursor:pointer; background:rgba(255,255,255,0.06); color:inherit;}
  canvas{max-width:100%; border-radius:8px; background:#111; display:block;}
  .info{color:#9aa6b2; font-size:13px;}
  .row{display:flex; gap:8px; align-items:center;}
  select, input[type=color]{padding:6px; border-radius:8px; border:0; background:rgba(255,255,255,0.03); color:inherit;}
  a.download{display:inline-block; padding:8px 10px; border-radius:8px; background:#06b6d4; color:#012; font-weight:700; text-decoration:none;}
  .small{font-size:13px; color:#9aa6b2;}
</style>
</head>
<body>
  <div class="left card">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div>
        <h1>Автоматический вырез — объект в центре</h1>
        <div class="small">Загрузите фото — инструмент попытается автоматически вырезать центральный объект</div>
      </div>
      <div class="info">Работает полностью в браузере</div>
    </div>

    <div class="controls">
      <label class="btn" id="uploadLabel">Загрузить фото
        <input id="fileInput" type="file" accept="image/*">
      </label>
      <button id="retryBtn">Повторно обработать</button>
      <button id="resetBtn">Очистить</button>
      <div style="margin-left:auto;" class="small">Макс обработка ~ до 1200px</div>
    </div>

    <div style="display:flex; gap:12px; align-items:flex-start; margin-top:8px;">
      <div style="flex:1;">
        <canvas id="sourceCanvas"></canvas>
        <div class="info">Источник</div>
      </div>

      <div style="width:260px;">
        <canvas id="resultCanvas" width="240" height="160"></canvas>
        <div class="info">Результат (предпросмотр)</div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label class="small">Фон:
            <select id="bgMode">
              <option value="transparent">Прозрачный (PNG)</option>
              <option value="white">Белый</option>
              <option value="color">Цвет</option>
            </select>
          </label>
          <input type="color" id="bgColor" value="#ffffff" style="display:none;">
        </div>
        <div style="margin-top:10px; display:flex; gap:8px;">
          <a id="downloadLink" class="download" href="#" download="cut.png" style="pointer-events:none;opacity:0.6">Скачать</a>
          <button id="openBtn">Открыть в новом окне</button>
        </div>
        <div class="info" style="margin-top:8px;">Если результат плох — нажмите "Повторно обработать" или уменьшите картинку вручную в редакторе перед загрузкой.</div>
      </div>
    </div>

  </div>

  <aside class="right card">
    <strong>Параметры обработки</strong>
    <div style="margin-top:8px;" class="small">
      Алгоритм (упрощённый):
      <ul>
        <li>Берём цвета границ → считаем «фоновой» цвет</li>
        <li>Каждый пиксель — расстояние до фона → порог</li>
        <li>Морфология, поиск компоненты ближе к центру</li>
        <li>Копируем только эту компоненту — создаём PNG</li>
      </ul>
    </div>

    <div style="margin-top:8px;" class="row">
      <label class="small">Порог (чем больше — тем строже)
        <input id="threshold" type="range" min="15" max="120" value="45" style="width:150px;margin-left:6px;">
      </label>
      <div id="thVal" class="small">45</div>
    </div>

    <div style="margin-top:8px;" class="row">
      <label class="small">Миним. размер компоненты
        <input id="minComp" type="range" min="200" max="20000" value="800" style="width:150px;margin-left:6px;">
      </label>
      <div id="mcVal" class="small">800</div>
    </div>

    <div style="margin-top:12px;" class="info">Подходит для фото, где объект в центре и фон относительно однотонный. Для сложных фонов требуется более продвинутый метод.</div>
  </aside>

<script>
/* Автоматическое вырезание центрального объекта — чистый JS, Canvas API. */
const fileInput = document.getElementById('fileInput');
const uploadLabel = document.getElementById('uploadLabel');
const sourceCanvas = document.getElementById('sourceCanvas');
const resultCanvas = document.getElementById('resultCanvas');
const ctxS = sourceCanvas.getContext('2d');
const ctxR = resultCanvas.getContext('2d');
const downloadLink = document.getElementById('downloadLink');
const openBtn = document.getElementById('openBtn');
const bgMode = document.getElementById('bgMode');
const bgColor = document.getElementById('bgColor');
const thresholdSlider = document.getElementById('threshold');
const thVal = document.getElementById('thVal');
const minComp = document.getElementById('minComp');
const mcVal = document.getElementById('mcVal');
const retryBtn = document.getElementById('retryBtn');
const resetBtn = document.getElementById('resetBtn');

let img = new Image();
let currentMask = null;
let processedBlobUrl = null;

const MAX_DIM = 1200; // максимальная длинная сторона для обработки

thresholdSlider.addEventListener('input', ()=>{ thVal.innerText = thresholdSlider.value; });
minComp.addEventListener('input', ()=>{ mcVal.innerText = minComp.value; });
bgMode.addEventListener('change', ()=>{ bgColor.style.display = (bgMode.value === 'color') ? 'inline-block' : 'none'; });

fileInput.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    img = new Image();
    img.onload = ()=> {
      loadAndProcessImage();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(f);
});

retryBtn.addEventListener('click', ()=> { if(img && img.src) loadAndProcessImage(); });
resetBtn.addEventListener('click', ()=> { resetAll(); });

openBtn.addEventListener('click', ()=>{
  if(!processedBlobUrl) return alert('Сначала обработайте изображение');
  window.open(processedBlobUrl, '_blank');
});

downloadLink.addEventListener('click', ()=>{
  if(!processedBlobUrl) { alert('Сначала обработайте изображение'); return; }
});

function resetAll(){
  ctxS.clearRect(0,0,sourceCanvas.width,sourceCanvas.height);
  ctxR.clearRect(0,0,resultCanvas.width,resultCanvas.height);
  downloadLink.style.pointerEvents='none';
  downloadLink.style.opacity=0.6;
  downloadLink.removeAttribute('href');
  if(processedBlobUrl){ URL.revokeObjectURL(processedBlobUrl); processedBlobUrl=null; }
  fileInput.value='';
}

/* Основной поток */
function loadAndProcessImage(){
  // подготовка канвы: масштабим до MAX_DIM
  let w = img.naturalWidth, h = img.naturalHeight;
  const scale = Math.min(1, MAX_DIM / Math.max(w, h));
  w = Math.round(w * scale); h = Math.round(h * scale);
  sourceCanvas.width = w; sourceCanvas.height = h;
  ctxS.clearRect(0,0,w,h);
  ctxS.drawImage(img, 0, 0, w, h);

  // очистим старый результат
  ctxR.clearRect(0,0,resultCanvas.width, resultCanvas.height);
  currentMask = null;
  if(processedBlobUrl){ URL.revokeObjectURL(processedBlobUrl); processedBlobUrl=null; }

  // асинхронно (чтобы интерфейс не подвис), используем setTimeout
  setTimeout(()=> {
    try {
      const mask = createMaskAuto(w,h);
      currentMask = mask;
      const compMask = selectCentralComponent(mask, w, h, parseInt(minComp.value,10));
      drawResultFromComponent(compMask, w, h);
    } catch(err){
      console.error(err);
      alert('Ошибка при обработке изображения: ' + err.message);
    }
  }, 30);
}

/* 1) Оценим "фон" — средний цвет границ */
function estimateBorderColor(w,h,ctx){
  const imgd = ctx.getImageData(0,0,w,h).data;
  const sample = {r:0,g:0,b:0,count:0};
  const step = Math.max(1, Math.floor(Math.min(w,h) / 40)); // плотность выборки
  // верх/низ
  for(let x=0;x<w;x+=step){
    for(let y of [0, h-1]){
      const idx = (y*w + x) * 4;
      sample.r += imgd[idx]; sample.g += imgd[idx+1]; sample.b += imgd[idx+2]; sample.count++;
    }
  }
  // левый/правый
  for(let y=0;y<h;y+=step){
    for(let x of [0, w-1]){
      const idx = (y*w + x) * 4;
      sample.r += imgd[idx]; sample.g += imgd[idx+1]; sample.b += imgd[idx+2]; sample.count++;
    }
  }
  return {
    r: sample.r / sample.count,
    g: sample.g / sample.count,
    b: sample.b / sample.count
  };
}

/* 2) Построим маску: dist(color, bgColor) > threshold */
function createMaskAuto(w,h){
  const imgd = ctxS.getImageData(0,0,w,h);
  const data = imgd.data;
  const bg = estimateBorderColor(w,h,ctxS);
  const threshold = parseInt(thresholdSlider.value,10); // порог
  const mask = new Uint8Array(w*h); // 0/1 mask

  // compute distance and fill mask
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i = (y*w + x) * 4;
      const dr = data[i] - bg.r;
      const dg = data[i+1] - bg.g;
      const db = data[i+2] - bg.b;
      const dist = Math.sqrt(dr*dr + dg*dg + db*db);
      mask[y*w + x] = (dist > threshold) ? 1 : 0;
    }
  }

  // morphological open/close to remove noise
  const cleaned = morphologicalCleanup(mask, w, h);
  return cleaned;
}

/* Простая морфология: сначала эрозия, затем дилатация (opening) и затем closing */
function morphologicalCleanup(mask, w, h){
  const iter = 1;
  let tmp = erode(mask, w, h, iter);
  tmp = dilate(tmp, w, h, iter);
  // closing to fill holes
  tmp = dilate(tmp, w, h, 1);
  tmp = erode(tmp, w, h, 1);
  return tmp;
}
function erode(mask, w, h, iterations=1){
  let inMask = mask;
  let out = new Uint8Array(w*h);
  const neighbors = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
  for(let it=0; it<iterations; it++){
    out.fill(0);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const idx = y*w + x;
        if(inMask[idx]===0) continue;
        let ok = true;
        for(const n of neighbors){
          const nx = x + n[0], ny = y + n[1];
          if(nx<0||ny<0||nx>=w||ny>=h || inMask[ny*w + nx] === 0){ ok = false; break; }
        }
        out[idx] = ok ? 1 : 0;
      }
    }
    inMask = out.slice();
  }
  return inMask;
}
function dilate(mask, w, h, iterations=1){
  let inMask = mask;
  let out = new Uint8Array(w*h);
  const neighbors = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
  for(let it=0; it<iterations; it++){
    out.fill(0);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const idx = y*w + x;
        if(inMask[idx]===1){ out[idx] = 1; continue; }
        let near = false;
        for(const n of neighbors){
          const nx = x + n[0], ny = y + n[1];
          if(nx<0||ny<0||nx>=w||ny>=h) continue;
          if(inMask[ny*w + nx] === 1){ near = true; break; }
        }
        out[idx] = near ? 1 : 0;
      }
    }
    inMask = out.slice();
  }
  return inMask;
}

/* 3) Найдём компоненты и выберем ту, что ближе к центру и достаточно большая */
function selectCentralComponent(mask, w, h, minSize){
  const label = new Int32Array(w*h);
  let curLabel = 0;
  const q = [];
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for(let i=0;i<w*h;i++) label[i]=0;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = y*w + x;
      if(mask[idx] === 1 && label[idx] === 0){
        curLabel++;
        label[idx] = curLabel;
        q.push(idx);
        let qhead = 0;
        while(qhead < q.length){
          const id = q[qhead++]; const yy = Math.floor(id / w), xx = id % w;
          for(const d of dirs){
            const nx = xx + d[0], ny = yy + d[1];
            if(nx<0||ny<0||nx>=w||ny>=h) continue;
            const nidx = ny*w + nx;
            if(mask[nidx] === 1 && label[nidx] === 0){ label[nidx] = curLabel; q.push(nidx); }
          }
        }
        q.length = 0;
      }
    }
  }

  if(curLabel === 0){
    // ничего не найдено — вернём исходную маску
    return mask;
  }

  // статистика по меткам
  const stats = new Array(curLabel+1);
  for(let i=0;i<=curLabel;i++) stats[i] = {count:0, sumx:0, sumy:0};
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = y*w + x;
      const lab = label[idx];
      if(lab>0){
        stats[lab].count++;
        stats[lab].sumx += x;
        stats[lab].sumy += y;
      }
    }
  }

  // найдём компоненту, чья центроид ближе к центру изображения и размер > minSize
  const cx = w/2, cy = h/2;
  let bestLab = -1;
  let bestScore = 1e18;
  for(let lab=1; lab<=curLabel; lab++){
    const s = stats[lab];
    if(s.count < minSize) continue;
    const centroidX = s.sumx / s.count;
    const centroidY = s.sumy / s.count;
    const dist2 = (centroidX - cx)*(centroidX - cx) + (centroidY - cy)*(centroidY - cy);
    if(dist2 < bestScore){
      bestScore = dist2; bestLab = lab;
    }
  }

  // если не нашлось ни одной подходящей по размеру — возьмём компоненту ближайшую к центру независимо от размера
  if(bestLab === -1){
    for(let lab=1; lab<=curLabel; lab++){
      const s = stats[lab];
      const centroidX = s.sumx / (s.count||1);
      const centroidY = s.sumy / (s.count||1);
      const dist2 = (centroidX - cx)*(centroidX - cx) + (centroidY - cy)*(centroidY - cy);
      if(dist2 < bestScore){
        bestScore = dist2; bestLab = lab;
      }
    }
  }

  // сформируем маску для выбранной метки
  const out = new Uint8Array(w*h);
  for(let i=0;i<w*h;i++) out[i] = (label[i] === bestLab) ? 1 : 0;
  return out;
}

/* 4) Отрисуем результат: копируем пиксели выбранной маски, создаём PNG */
function drawResultFromComponent(compMask, w, h){
  // result canvas size = source size (можно менять)
  resultCanvas.width = w;
  resultCanvas.height = h;
  resultCanvas.style.width = Math.min(320, w) + 'px';
  resultCanvas.style.height = 'auto';

  // подготовим фон
  ctxR.clearRect(0,0,w,h);
  if(bgMode.value === 'white'){
    ctxR.fillStyle = '#ffffff'; ctxR.fillRect(0,0,w,h);
  } else if(bgMode.value === 'color'){
    ctxR.fillStyle = bgColor.value; ctxR.fillRect(0,0,w,h);
  } else {
    // transparent -> clear (do nothing)
    ctxR.clearRect(0,0,w,h);
  }

  // получим данные исходного изображения
  const srcData = ctxS.getImageData(0,0,w,h);
  const outImg = ctxR.getImageData(0,0,w,h);

  // если фон выбран (не transparent) — мы уже залили bg, просто наложим изображение там, где mask=1
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i = (y*w + x);
      const ii = i*4;
      if(compMask[i] === 1){
        outImg.data[ii]   = srcData.data[ii];
        outImg.data[ii+1] = srcData.data[ii+1];
        outImg.data[ii+2] = srcData.data[ii+2];
        outImg.data[ii+3] = (bgMode.value === 'transparent') ? srcData.data[ii+3] : 255;
      } else {
        // если прозрачный фон — alpha = 0
        if(bgMode.value === 'transparent'){
          outImg.data[ii+3] = 0;
        }
        // если цветной фон — оставляем уже залитый фон (значения уже установлены)
      }
    }
  }
  ctxR.putImageData(outImg, 0, 0);

  // подготовим ссылку для скачивания — используем blob
  resultCanvas.toBlob((blob)=>{
    if(!blob) { alert('Не удалось сформировать изображение'); return; }
    if(processedBlobUrl) URL.revokeObjectURL(processedBlobUrl);
    processedBlobUrl = URL.createObjectURL(blob);
    downloadLink.href = processedBlobUrl;
    downloadLink.style.pointerEvents='auto';
    downloadLink.style.opacity=1;
    // autofocus: открыть в новом окне не автоматически по требованию — пользователь нажмёт сам
  }, 'image/png');
}

</script>
</body>
</html>
