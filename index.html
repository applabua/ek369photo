<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Indigo Auto Cut — исправленная версия</title>
<style>
  :root{--bg:#0f1530;--card:#171a37;--accent:#7ea8ff;--muted:#bfc9ff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{max-width:980px;margin:18px auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  header{display:flex;align-items:center;gap:12px;justify-content:space-between}
  h1{color:var(--accent);margin:0;font-size:20px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:linear-gradient(180deg,var(--accent),#9fc0ff);color:#071028;border:none;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px;border-radius:14px}
  #stage{display:flex;gap:12px;flex-wrap:wrap}
  canvas{max-width:100%;border-radius:12px;background:#fff;display:block}
  .small{font-size:13px;color:#bfc9ff}
  @media(max-width:720px){#stage{flex-direction:column}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Indigo Auto Cut — fixed</h1>
    <div class="small">Автовырез (GrabCut) — исправленная версия</div>
  </header>

  <div class="card controls">
    <label style="padding:8px 12px;border-radius:10px;border:2px dashed rgba(126,168,255,0.25);cursor:pointer">
      Нажми / перетащи фото
      <input id="file" type="file" accept="image/*" style="display:none">
    </label>
    <button class="btn ghost" id="runBtn">Запустить авто-вырез</button>
    <button class="btn ghost" id="rectShrink">Уменьшить рамку</button>
    <button class="btn ghost" id="rectGrow">Увеличить рамку</button>
    <button class="btn" id="downloadBtn" style="pointer-events:none;opacity:0.6">Скачать PNG</button>
    <div style="margin-left:auto" class="small">Работает локально (OpenCV.js)</div>
  </div>

  <div id="stage">
    <div style="flex:1" class="card">
      <canvas id="srcCanvas"></canvas>
      <div class="small">Исходное изображение — рамка показывает область GrabCut</div>
    </div>

    <div style="width:260px" class="card">
      <canvas id="outCanvas" width="240" height="160"></canvas>
      <div class="small">Результат (предпросмотр)</div>
      <div style="margin-top:8px;font-size:13px;color:#9da8d6">
        Подсказки:
        <ul>
          <li>Загрузите фото → нажмите "Запустить авто-вырез".</li>
          <li>Если фон попал в объект — уменьшите рамку.</li>
          <li>Нажмите "Скачать PNG".</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="card small" id="status">Загрузка OpenCV.js...</div>
</div>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/3.4.0/opencv.js"></script>

<script>
/* Исправленный runGrabCut: конвертация в CV_8UC3 перед grabCut */
let fileInput = document.getElementById('file');
let srcCanvas = document.getElementById('srcCanvas');
let outCanvas = document.getElementById('outCanvas');
let runBtn = document.getElementById('runBtn');
let downloadBtn = document.getElementById('downloadBtn');
let rectGrow = document.getElementById('rectGrow');
let rectShrink = document.getElementById('rectShrink');
let statusEl = document.getElementById('status');

let srcCtx = srcCanvas.getContext('2d');
let outCtx = outCanvas.getContext('2d');

let img = new Image();
let imgLoaded = false;
let rectFactor = 0.70;
let latestResultBlobUrl = null;

// загрузка картинки
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = ()=>{
    URL.revokeObjectURL(url);
    fitAndDrawImage();
    imgLoaded = true;
  };
  img.src = url;
});

function fitAndDrawImage(){
  const maxDim = Math.min(window.innerWidth - 100, 1280);
  let w = img.naturalWidth, h = img.naturalHeight;
  const scale = Math.min(1, maxDim / Math.max(w,h));
  w = Math.round(w * scale); h = Math.round(h * scale);

  srcCanvas.width = w; srcCanvas.height = h;
  srcCtx.clearRect(0,0,w,h);
  srcCtx.drawImage(img, 0, 0, w, h);
  drawRectOverlay();
}

function drawRectOverlay(){
  const w = srcCanvas.width, h = srcCanvas.height;
  const rw = Math.round(w * rectFactor), rh = Math.round(h * rectFactor);
  const rx = Math.round((w - rw) / 2), ry = Math.round((h - rh) / 2);
  srcCtx.drawImage(img, 0, 0, w, h);
  srcCtx.save();
  srcCtx.strokeStyle = '#7ea8ff';
  srcCtx.lineWidth = 3;
  srcCtx.setLineDash([8,6]);
  srcCtx.strokeRect(rx+1, ry+1, rw-2, rh-2);
  srcCtx.restore();
}
rectGrow.addEventListener('click', ()=>{ rectFactor = Math.min(0.98, rectFactor + 0.06); drawRectOverlay(); });
rectShrink.addEventListener('click', ()=>{ rectFactor = Math.max(0.2, rectFactor - 0.06); drawRectOverlay(); });

// ожидание OpenCV
(function waitForCV(){
  if(window.cv && cv.Mat){
    statusEl.innerText = 'OpenCV.js загружен — можно загружать фото';
    return;
  }
  statusEl.innerText = 'Загрузка OpenCV.js...';
  setTimeout(waitForCV, 300);
})();

// основная функция (исправлена)
runBtn.addEventListener('click', async ()=>{
  if(!imgLoaded){ alert('Сначала загрузите картинку'); return; }
  if(!window.cv || !cv.imread){ alert('OpenCV.js ещё не загрузился — подождите'); return; }
  try {
    await runGrabCut();
  } catch(e){
    console.error(e);
    alert('Ошибка: ' + e.message);
  }
});

downloadBtn.addEventListener('click', ()=>{
  if(!latestResultBlobUrl){ alert('Сначала получите результат'); return; }
  const a = document.createElement('a'); a.href = latestResultBlobUrl; a.download = 'cut_result.png'; a.click();
});

async function runGrabCut(){
  const w = srcCanvas.width, h = srcCanvas.height;

  // читать канвас (обычно даёт RGBA)
  let src = cv.imread(srcCanvas); // likely CV_8UC4
  // конвертируем в 3-канальное CV_8UC3 (RGB) — это важно для grabCut
  let srcRGB = new cv.Mat();
  cv.cvtColor(src, srcRGB, cv.COLOR_RGBA2RGB);

  // маска (8U single channel)
  let mask = new cv.Mat();
  mask.create(srcRGB.rows, srcRGB.cols, cv.CV_8UC1);
  mask.setTo(new cv.Scalar(cv.GC_BGD));

  // rect
  const rw = Math.round(w * rectFactor), rh = Math.round(h * rectFactor);
  const rx = Math.round((w - rw) / 2), ry = Math.round((h - rh) / 2);
  const rect = new cv.Rect(rx, ry, rw, rh);

  // bgd/fgd модели
  let bgdModel = new cv.Mat();
  let fgdModel = new cv.Mat();

  // запускаем grabCut на RGB-изображении
  cv.grabCut(srcRGB, mask, rect, bgdModel, fgdModel, 5, cv.GC_INIT_WITH_RECT);

  // формируем бинарную маску: оставляем GC_FGD(1) и GC_PR_FGD(3)
  let outMask = new cv.Mat();
  outMask.create(mask.rows, mask.cols, cv.CV_8UC1);
  const maskData = mask.data;
  const outData = outMask.data;
  for(let i=0;i<maskData.length;i++){
    const v = maskData[i];
    outData[i] = (v === cv.GC_FGD || v === cv.GC_PR_FGD) ? 255 : 0;
  }

  // немного сглаживаем края
  let ksize = new cv.Size(3,3);
  cv.GaussianBlur(outMask, outMask, ksize, 0);

  // создаём RGBA-вывод из RGB-источника
  let rgba = new cv.Mat();
  cv.cvtColor(srcRGB, rgba, cv.COLOR_RGB2RGBA);

  // записываем альфу из outMask
  // rgba.data — байтовый массив длиной rows*cols*4
  const rgbaData = rgba.data;
  for(let i=0, j=0; i<outData.length; i++, j+=4){
    rgbaData[j+3] = outData[i]; // alpha = 0..255
  }

  // показать результат на канвасе
  // убедимся что outCanvas = размер изображения
  outCanvas.width = rgba.cols;
  outCanvas.height = rgba.rows;
  cv.imshow(outCanvas, rgba);

  // подготовить blob для скачивания
  const blob = await new Promise(resolve => outCanvas.toBlob(b => resolve(b), 'image/png'));
  if(latestResultBlobUrl) URL.revokeObjectURL(latestResultBlobUrl);
  latestResultBlobUrl = URL.createObjectURL(blob);
  downloadBtn.style.pointerEvents = 'auto';
  downloadBtn.style.opacity = 1;

  // очистка mats
  src.delete(); srcRGB.delete(); mask.delete(); bgdModel.delete(); fgdModel.delete();
  outMask.delete(); rgba.delete();
}
</script>
</body>
</html>
