<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Автовырез объекта</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; padding: 20px; background: #f0f0f0; }
  canvas { margin-top: 20px; border: 1px solid #ccc; background: white; }
  input { margin-top: 20px; }
</style>
</head>
<body>

<h2>Автоматическое вырезание объекта</h2>
<input type="file" id="upload" accept="image/*">
<br>
<canvas id="canvas"></canvas>

<script>
const upload = document.getElementById("upload");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// Белый фон (если нужен прозрачный — закомментируй заливку фона)
const BACKGROUND_COLOR = "white";

upload.addEventListener("change", async () => {
    const file = upload.files[0];
    if (!file) return;

    const img = new Image();
    img.src = URL.createObjectURL(file);

    img.onload = async () => {
        canvas.width = img.width;
        canvas.height = img.height;

        // Загружаем изображение в сегментационную модель
        const session = await ort.InferenceSession.create(
            "https://raw.githubusercontent.com/xinntao/Real-ESRGAN/master/examples/input/segmentation.onnx"
        );

        const inputTensor = new ort.Tensor("float32", preprocessImage(img), [1, 3, img.height, img.width]);
        const results = await session.run({ input: inputTensor });
        const mask = results.output.data;

        // Рисуем белый фон
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Рисуем только выделенный объект
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        const imgCanvas = document.createElement("canvas");
        imgCanvas.width = img.width;
        imgCanvas.height = img.height;
        const imgCtx = imgCanvas.getContext("2d");
        imgCtx.drawImage(img, 0, 0);
        const originalPixels = imgCtx.getImageData(0, 0, img.width, img.height).data;

        for (let i = 0; i < mask.length; i++) {
            if (mask[i] > 0.5) { // объект
                pixels[i*4] = originalPixels[i*4];
                pixels[i*4+1] = originalPixels[i*4+1];
                pixels[i*4+2] = originalPixels[i*4+2];
                pixels[i*4+3] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);
    };
});

// Простейшая функция нормализации картинки
function preprocessImage(img) {
    const tmpCanvas = document.createElement("canvas");
    tmpCanvas.width = img.width;
    tmpCanvas.height = img.height;
    const tmpCtx = tmpCanvas.getContext("2d");
    tmpCtx.drawImage(img, 0, 0);
    const { data } = tmpCtx.getImageData(0, 0, img.width, img.height);
    const floatData = new Float32Array(img.width * img.height * 3);
    for (let i = 0; i < img.width * img.height; i++) {
        floatData[i] = data[i * 4] / 255;
        floatData[i + img.width * img.height] = data[i * 4 + 1] / 255;
        floatData[i + img.width * img.height * 2] = data[i * 4 + 2] / 255;
    }
    return floatData;
}
</script>

<!-- ONNX Runtime JS -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

</body>
</html>
